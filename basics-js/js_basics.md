# Javascript basics

## Code style

*https://github.com/airbnb/javascript*

## ReplIT

*https://replit.com/@naavI/JS#index.js*

## Linter

*https://eslint.org*


## Links useful

- https://habr.com/ru/post/249525/

## Syntax
 
```js
console.log(' \"  ')
```

```js
let greeting = 'Father!';

undefined 
```

Понятие "выражение":
- строки
- операция
- вызов функции
- 

Отличать от "инструкции", например:
- определение переменной

```js
42 * 2
'Hasta' + ' ' + 'la vista'
```

Programm start from command line:

```js
node solution.js 
```

## Naming
- https://ru.hexlet.io/blog/posts/naming-errors-1
- https://ru.hexlet.io/blog/posts/naming-in-programming

Cases toDo:

- isTrue - Predicat - True / False?
- hasSmth - is object in some range?
- smthCount - counter

- functions name - verbs (do / call / start)
- variables - nouns usually 

- array - in multiple 'users', 'cars'

Examples:
```js
// Нормализация данных
normalizeDomainName('hexlet.io');

// Извлечение части данных
getName(user);
getDomainFromEmail('support@hexlet.io');

// Получение массива с ошибками
const errors = validate(user);
if (errors.length > 0) {
  // ...
}

// Подсчеты
calculateDiff(first, second)

// Допуск
canSwim(user)
canViewProfile(user)
```

## Интерполяция


```js

const firstName = 'Joffrey';
const greeting = 'Hello';

// Обратите внимание на ограничители строки, это бектики
// Интерполяция не работает с одинарными и двойными кавычками
console.log(`${greeting}, ${firstName}!`);
// => 'Hello, Joffrey!'

```

Литерал - запись в программе, фиксированное значение

## Функции

Необязательность передаваемых параметров описывается скобками [ ], точно так же описываются и опциональные параметры, у которых есть значения по умолчанию. Возможность передачи любого числа параметров зашита в этой части [, ...].
```
Math.max([value1[, value2[, ...]]])
```

## Детерминированные функции

Функция называется детерминированной тогда, когда для одних и тех же входных параметров она возвращает один и тот же результат.

Функция, возвращающая случайное число, не является детерминированной, так как у одного и того же входа (даже если он пустой, то есть параметры не принимаются) мы получим всегда разный результат

## Побочные эффекты

С точки зрения программы вывод на экран — это так называемый побочный эффект.

Побочным эффектом называют действия, которые изменяют внешнее окружение (среду выполнения). К таким действиям относятся:

- любые сетевые взаимодействия,
- взаимодействие с файловой системой (чтение и запись файлов),
- вывод информации на экран или печать на принтере,
- и так далее.

Побочные эффекты — один из основных источников проблем и ошибок в программных системах. Код с побочными эффектами сложен в тестировании, ненадежен.

При этом без побочных эффектов программирование не имеет смысла. Без них было бы невозможно получить результат работы программы (записать в базу, вывести на экран, отправить по сети и так далее).

Если вызвать функцию с побочным эффектом дважды с одним и тем же набором значений входных аргументов, может случиться так, что в качестве результата будут возвращены разные значения. Такие функции называются И недетерминированными функциями, И функциями с побочными эффектами.

**Недетерминированность функции** — возможность возвращения функцией разных значений несмотря на то, что ей передаются на вход одинаковые значения входных аргументов. В этом случае невозможно построить однозначную таблицу значений функции; для таких функций таблицы значений выглядят как список (может быть, бесконечный) возможных значений, которые функция принимает на заданном наборе входных параметров.

Функция является детерминированной, если для одного и того же набора входных значений она **возвращает** одинаковый результат.

Другим видом побочных эффектов является модификация переданных в функцию параметров (переменных), когда в процессе вычисления выходного значения функции изменяется и значение входного параметра.

## Побочные эффекты и детерминированность - разные плоскости

Обычно функции, обладающие побочными эффектами, не являются детерминированными, поэтому функции без побочных эффектов, детерминированные функции и чистые функции иногда путают. 

В действительности это разные свойства функций. 

Например, функция rand, которая возвращает случайное число, или гипотетическая функция GetGlobalVarX, которая возвращает значение глобальной переменной X (и больше ничего не делает), не являются детерминированными, хотя они и не обладают побочными эффектами. 

А вот гипотетическая функция print, выводящая текст на экран и всегда возвращающая 0, наоборот — является детерминированной, но обладает побочным эффектом (вывод текста на экран). Ни одна из них не является чистой.

## Чистая функция

Это функция, которая:

1. является детерминированной;
2. не обладает побочными эффектами.

Наличия только одного из свойств недостаточно для того, чтобы функция была чистой.

## Поиск информации в гугле

Язык запросов
Каждая поисковая система обладает языком запросов. В него входят специальные операторы, позволяющие более точно указать то, что вы хотите. Вот некоторые важные возможности:

- ```site:stackoverflow.com how to test react code``` — поиск будет произведен среди страниц сайта Stackoverflow.

- ```add class to element -jquery``` — дефисом обозначаются стоп-слова, то есть будут найдены все варианты, в которых эти слова не упоминаются.

- ```"immutable js"``` — двойные кавычки указывают на то, что нужно искать точное совпадение.

## Получить тип значения

`type of VARAIBLE_NAME`


## let VS const - объявление переменных

Переменные не изменяемые - `const`

Изменяемые - `let`

## Определение функции

```js
// Минимальное определение функции
const noop = () => {
  // Тут мог бы быть код, но его нет
};

noop();
```

Определение
```
() => {
  // Работающий, но бесполезный код
};
```

! Присваивание

**Определение функции должно начинаться с ключевого слова const**

```
const nameOfFunction = ...
```

## Свежий способ определения

```js
const double = (x) => x ** 2;
```

Если же стоят фигурные скобки, то это не сокращенная форма, а значит, чтобы функция вернула значение, придется поставить return.
**Так не сработает:**
```
const sum = (a, b) => { a + b };
```



## Значения по умолчанию 

```js
// Второй параметр имеет значение по умолчанию 2
const pow = (x, base = 2) => {
  return x ** base;
};
```
## Operators boolean

```js
&&

||

!

```
**Оператор ИЛИ** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в true.


**Оператор И** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в false.


В JavaScript есть два простых правила, по которым происходят преобразования:

- 0, '' (пустая строка), undefined, NaN, null приводятся к false. Эти значения называют falsy.
- Все остальное приводится к true

## IF


if - конструкция языка, управляющая порядком выполнения инструкций. В скобках ей передается выражение-предикат, а затем описывается блок кода в фигурных скобках. Этот блок кода будет выполнен, только если предикат — истина


```js

  if () {
    
  } else if (lastChar === '!') {
    
  } else {
    
  }

```
## Полезные функции

```js

site.startsWith()

```

## Тернарный оператор

Тернарный оператор — единственный в своем роде оператор, требующий три операнда:

```js
const abs = (number) => {
  return number >= 0 ? number : -number;
};
```

```js
const abs = (number) => (number >= 0 ? number : -number);
```

```js
return (lastChar === '?') ? 'question' : 'normal';
```

## Case

```js
switch (status) {
  case 'processing': // status === 'processing' (строгое соответствие)
    // Делаем раз
    break;
}

```

## While

```js
while (true) {
  // Что-то делаем
}
```

## Импорт функций и библиотек


В конце файла, **из которого импортируется**

```js
export { functionName };


// Экспорт по умолчанию - в конце файла, из которого импортируется функция

export default functionName;


// export перед тем, что экпортируется

// константа
export const e = 2.718;

// или функция
export const square = (x) => {
  return x * x;
};



// Можно также экспортировать функцию или константу без имени:

export default (r) => {
  return 4 * pi * square(r);
};

// При экспорте функции без имени, ее имя в модуле будет определяться в момент импорта, т.е. один и тот же экспорт может иметь разные имена в разных модулях:

// math.js
export default () => {
  ///
};

// import1.js:
import something1 from './math.js';

// экспорт по умолчанию может сочетаться с обычным экспортом, а экспортировать элементы можно по отдельности:
export { e, pi };
export { square };
export default surfaceArea;

// импорт в этом случае
import surfaceArea,  { square, e, pi } from './math.js';
```
Экспортированное по умолчанию свойство считается «главным» в этом модуле

----


В файле, **куда импортируется**

! при этом следует указывать расширение файла .js

```js
import { functionName } from './file.js';
// ./ - оба файла в одном каталоге

// импорт всего и с алиасом имени модуля

import * as aliasName from './file.js';

...  mathematics.functionName();


// импорт по умолчанию без фигурных скобок
import surfaceArea from './math.js';

// алиас для функции
import { square as square1, e as e1, pi as pi1 } from './math1.js';

// Если from 'name' содержит только имя, без ./ в начале, значит модуль подгружается либо из стандартной библиотеки nodejs, либо из установленных пакетов

```

Польза дефолтного экспорта — при импорте можно назвать его, как угодно.

-------
