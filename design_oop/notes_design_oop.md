# Объектно-ориентированный дизайн

https://ru.hexlet.io/courses/js-object-oriented-design/ 

## Паттерны проектирования

повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста. 

Антипаттерны: https://ru.wikipedia.org/wiki/Антипаттерн

## Изменения в конфигурации
если для конкретного запроса, нужно временно установить опции, отличные от тех что были переданы в конструктор

Через передачу дополнительного параметра в метод. Этот параметр содержит временные опции, которые применяются только для данного запроса

Конфигурацию следует задавать череза
- конструктор при создании объекта
- через передачу параметра в метод на время "включить и потом вернуть обратно (вызвать метод снова, но со стартовым значением параметра)"

## Объекты

- Сущности (entities objects)
- Значения
- Встраиваемые объекты

##  Текучий интерфейс (Fluent Interface). 

При таком способе организации кода, обработка выглядит как цепочка подряд идущих методов

возвращать не this, а создавать новый объект того же типа с обновленной коллекцией

## Builders and Validators - Сборщики и Валидаторы

Yup

```js

import * as yup from 'yup';

const schema = yup.string().required().email();

schema.validateSync(''); // ValidationError: this is a required field
schema.validateSync('wrongemail'); // ValidationError: this must be a valid email
schema.validateSync('support@hexlet.io'); // возвращает само значение

// методы positive() и integer() есть только у number
const schema1 = yup.number().required().positive().integer();

// массив должен содержать от 5 до 10 элементов
const schema2 = yup.array().min(5).max(10);


// object().shape() позволяет задать структуру объекта
const schema = yup.object().shape({
  name: yup.string().required(),
  age: yup.number().required().positive().integer(),
  email: yup.string().email(),
  website: yup.string().url(),
  createdOn: yup.date().default(() => new Date()), // значение по умолчанию
});

const data = {
  name: 'jimmy',
  age: 24,
};
schema.validateSync(data);
```

Online tools 

- https://jsonlint.com


## Proxy 

С помощью proxy-объекта можно управлять доступом к свойствам практически любых объектов. В прикладном коде такая задача встречается нечасто, хотя в библиотеках и фреймворках Proxy используется регулярно

```js
const proxy = new Proxy(target, handler);

// Первый параметр (target) — это объект, для которого нужно сделать прокси. Второй параметр (handler) – объект с обработчиками, которые перехватывают разные операции над исходным объектом (target).
```


пример, в котором Proxy возвращает значение по умолчанию, если свойства не существует:

```js
// Количество пользователей в разных странах
const usersCountByCountry = {};

const handlers = {
  get: (target, prop) => {
    // in проверяет наличие свойства по всей цепочке прототипов
    // В случае Proxy это правильнее чем _.has
    if (prop in target) {
      return target[prop];
    }

    return 0;
  },
};

// obj – обернул исходный объект
const obj = new Proxy(usersCountByCountry, handlers);

obj.russia; // 0
obj.russia += 1; // 1
obj.usa; // 0
```


Proxy оборачивает исходный объект и перехватывает запросы к нему. Делается это с помощью обработчиков, называемых ловушками (trap). Ловушки описываются как методы объекта, который передается вторым параметром в конструктор Proxy.

Всего в Proxy 13 ловушек, среди которых самые часто используемые это "get" и "set". С помощью них перехватываются все операции чтения (get) и записи (set).

Ловушка get вызывается при каждом обращении к любому свойству объекта. На вход ей передается исходный объект и имя свойства, к которому идет обращение. Внутри же, можно строить любую логику. В нашем примере мы возвращаем значение свойства из target, если оно существует, и 0 в случае его отсутствия.

## Принципы написания кода

Генеральная идея звучит так: грамотная абстракция – ключ к успеху. Обозначьте границы, рассмотрите варианты использования и реализуйте как-нибудь.

Правильно начинать с вариантов использования. Представить себе как будто библиотека уже написана и мы пробуем ей воспользоваться (TDD толкает именно к этому, поэтому оно так мощно работает). Прежде чем мы перейдем к коду, попробуйте ответить на вопрос, так ли нужны классы и ООП для реализации этой библиотеки?

Теперь, когда готов интерфейс библиотеки, можно приступать к ее реализации. Насколько важно, как она выполнена внутри? Откровенно говоря, не так важно. Внутренности останутся внутренностями, и никто про них не узнает, а их размер никогда не станет слишком большим (это всего лишь http библиотека). Это значит, что мы в любой момент можем их переписать. И делать это лучше не до, а после, когда накопится опыт поддержки и опыт использования. Только в этом случае появится настоящее понимание того, как лучше структурировать библиотеку внутри.

