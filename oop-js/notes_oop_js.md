# OOP in JavaScript

https://ru.hexlet.io/courses/js-introduction-to-oop/

## Инкапсуляция

Инкапсуляция – это объединение функций и данных в рамках одной структуры, внутреннее состояние которой (данные) скрыто от внешнего мира. Иинкапсуляция это и объединение, и сокрытие там, где оно есть. Там где его нет, это просто объединение

```js
const company = {
  name: 'Hexlet',
  country: {
    name: 'Finland',
    getName: function getName() {
      return this.name;
    }
  },
};

console.log(company.country.getName()); // => ?
```

Example

```js
const makeExample = (numer, denom) => ({
  numer,
  denom,
  setNumer(newNumer) {
    this.numer = newNumer;
  },
  setDenom(newDenom) {
    this.denom = newDenom;
  },
  getNumer() {
    return this.numer;
  },
  getDenom() {
    return this.denom;
  },
  toString() {
    return `${this.getNumer()}/${this.getDenom()}`;
  },
  add(rational) {
    const newNumer = this.getNumer() * rational.getDenom() + rational.getNumer() * this.getDenom();
    const newDenom = this.getDenom() * rational.getDenom();
    return makeExample(newNumer, newDenom);
  },
});
```

## Контекст

Функции, записанные внутрь свойств объектов, называют методами:

```js
const company = { name: 'Hexlet' };
// Создание функции, которая сразу же присваивается свойству getName и становится методом
company.getName = function() {
  return 'Hexlet';
};

// Вызов метода
company.getName(); // "Hexlet"



// При создании объекта
const obj = {
  getName: function() {
    return 'Hexlet'
  },
};

// Через присваивание константы
const company = { name: 'Hexlet' };

function getHexlet() {
  return 'Hexlet';
};
// Имя не принципиально
company.getName = getHexlet;

//

// Добавление нового сотрудника
company.addEmployee = function addEmployee(user) {
  // Важно, что на момент вызова, employees уже добавлен в company
  this.employees.push(user);
};
```
Доступ к данным объекта внутри метода делается через  
специальное ключевое слово this, называемое контекстом.

Внутри методов оно ссылается на текущий объект, к которому привязан метод.


## Присваивание одного this другому

this ссылается на текущий объект, к которому привязан метод. И здесь кроется ключевое отличие this в JavaScript от this в других языках. В JavaScript this у метода может измениться

Вызов той же самой функции из другого объекта привел к смене объекта, на который ссылается this. Эта особенность называется **поздним связыванием**

Лучше всего можно понять эту особенность, познакомившись с тем, как вызываются функции внутри самого JavaScript и откуда там берется this. Так как в JavaScript функции — это тоже объекты, то у них есть свои методы. Среди них есть метод call(), который и используется для вызова:
```js
const sayHi = () => 'Hi!';
sayHi.call(); // "Hi!"
```
Зачем так сделано? Дело в том, что первым параметром эта функция принимает контекст - объект, на который и будет ссылаться this внутри функции. Функции для этого не обязательно быть методом:
```js
const getName = function getName() {
  return this.name;
};

const company1 = { name: 'Hexlet' };
// Функция вызывается напрямую, она не является методом
getName.call(company1); // "Hexlet"

const company2 = { name: 'Hexlet Plus' };
getName.call(company2); // "Hexlet Plus"
```
В этом и заключается весь секрет this. Это контекст, который JavaScript прокидывает автоматически в функцию, если она вызывается как метод. В этом случае можно точно сказать, к какому объекту она принадлежит.. Значение this ссылается на тот объект, из которого происходит вызов метода.



```js
const company1 = { name: 'Hexlet', getName: function getName() { return this.name } };
const company2 = { name: 'Hexlet Plus' };

company1.getName(); // "Hexlet"

company2.getName = company1.getName;

// В обоих случаях одна и та же функция
company2.getName(); // "Hexlet Plus"
company1.getName(); // "Hexlet"
```

## Bind - связывание

Передача одной функции в другую 

```js
const printer = {
  name: 'Hexlet',
  print(greeting = 'hello') {
    console.log(`${greeting}, ${this.name}`);
  }
};

// Прямой запуск
printer.print();


// некорректная работа
setTimeout(printer.print, 1000); // => "hello, undefined"

// 
const print = printer.print;
print(); // => "hello, undefined"

// как работает
setTimeout(() => printer.print(), 1000);
// => "hello, Hexlet"

// Или без setTimeout
const fn = () => printer.print();
fn(); // => "hello, Hexlet"

// ИЛИ ТАК - оборачивание в функцию помогает передать какие-то данные внутрь
const value = 'hi';
setTimeout(() => printer.print(value), 1000);
// => "hi, Hexlet"
```

## Связывание (Bind)

Другой способ — использование метода bind() (переводится как связать). Метод bind() доступен у функций, и в его задачу входит связывание функции с каким-то контекстом. Результатом выполнения bind() будет новая функция, работающая как и исходная функция, но с привязанным к ней контекстом.

Связанная функция сливается со своим контекстом "намертво". Больше this не поменяется.



```js
// Контекстом является тот же объект printer, в котором определен метод
// bind вызывается на функции и возвращает функцию
const boundPrint = printer.print.bind(printer);

// Теперь можно так
boundPrint(); // => "hello, Hexlet"
setTimeout(boundPrint, 1000);
// Через секунду
// => "hello, Hexlet"

// Можно вызывать bind прямо по месту
// так как возвращается функция
setTimeout(printer.print.bind(printer), 1000);

 ```

Кроме контекста, bind() принимает на вход параметры, которые нужны функции. Причем не сразу все, а любую их часть. bind() подставит их в новую функцию (ту, что вернется из метода bind()) "частично". Эта техника называется "частичное применение функции". Так можно сразу применить нужные аргументы:

bind() полезен там, где привязка контекста и вызов функции происходят в разных местах и, как правило, в разное время. Мы встретимся с таким кодом, когда перейдем к асинхронности в JavaScript.



```js
setTimeout(printer.print.bind(printer, 'hi'), 1000);
// Через секунду
// => "hi, Hexlet"
```
Подход с bind() был популярен до появления стрелочных функций, сейчас его используют нечасто. Стрелочные функции проще для понимания и используются повсеместно.

можно использовать специально созданные для этого функции apply() и call():
```js
// func.apply(thisArg, [ argsArray])
print.apply(printer, ['hi']); // hi, Hexlet

// func.call([thisArg[, arg1, arg2, ...argN]])
print.call(printer, 'hi'); // hi, Hexlet
```
Эти функции внутри себя делают две вещи: меняют контекст и сразу же производят вызов функции. Разница лишь в том, как они работают с аргументами этих функций: apply() – принимает аргументы в виде массива вторым параметром, а call() ждёт на вход позиционные аргументы.

Эти функции позволяют делать довольно необычные вещи, например так:
```js
// Если контекста нет, то передают null
const numbers = [1, 10, 33, 9, 15]
const max = Math.max.apply(null, numbers); // 33

const numbers = [1, 10, 33, 9, 15]
const max = Math.max.call(null, ...numbers); // 33

```

## Стрелочные функции

контекст обычных функций зависит от места вызова

контекст стрелочных функций — от того места, где они были определены.

Стрелочная функция не имеет своего контекста, она связывается с лексическим окружением, то есть функцией, внутри которой определена стрелочная функция. Это очень важный момент. Именно функция верхнего уровня задаёт контекст стрелочной функции, а не что-то другое. И это поведение нельзя изменить с помощью функций call или bind.

## Конструктор

абстракция, которая скрывает от нас структуру этого объекта.

```js
// корректно и экономно
function getName() {
  return this.name;
};

function getWebsite() {
  return this.website;
};

// С точки зрения использования ничего не поменялось, но зато перестали копироваться функции.
const make = (name, website) => {
  return {
    name,
    website,
    getName,
    getWebsite,
  };
};

```
## New

```js

// Такую функцию принято называть конструктором (хотя технически это обычная функция с контекстом)
// Конструкторы пишутся с заглавной буквы
function Company(name, website) {
  this.name = name;
  this.website = website;
  // Методы по прежнему определены снаружи как обычные функции
  this.getName = getName;
  this.getWebsite = getWebsite;
};


//
const company = new Company('Hexlet', 'https://hexlet.io');
```


## Упаковка и распаковка  - для примитивных объектов

JavaScript автоматически упаковывает примитивные типы в соответствующие объекты, когда встречает вызовы методов на них (и затем автоматически распаковывает).

## toString() -
Вывод строкового представления объекта



## Классы

```js
// Каждый класс должен лежать в своем собственном файле
// Идеально если имя класса совпадает с именем файла с учетом регистра
class Company { // имя класса - это имя функции конструктора
  // Метод с именем constructor соответствует функции-конструктору
  // Он вызывается, когда мы делаем new Company(name, email)
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  // Это свойство getName с записанной в него обычной (function) функцией
  getName() {
    return this.name;
  }

  getEmail() {
    return this.email;
  }

  setEmail(email) {
    this.email = email;
  }
}

// С точки зрения использования не меняется ничего
const company = new Company('Hexlet', 'support@hexlet.io'); // вызывается метод constructor
console.log(company.getName()); // => "Hexlet"
```
классы в JavaScript нужны далеко не всегда. JavaScript — мощный язык программирования, который не заставляет использовать одну парадигму программирования (в отличие от Java, например). С его помощью просто делать простые вещи и при необходимости применять сложные концепции для сложных вещей.


##  Статические свойства и методы

Мы можем присвоить метод/свойство самому классу. 
Такие методы называются статическими.
Оно принадлежит только классу (не экземплярам класса) !

```js
class Money {
  // Определение статического свойства
  static rates = {
    usd: {
      eur: 0.7,
    },
    eur: {
      usd: 1.2,
    },
  };

  // Определение статического метода
  static setRate(from, to, value) {
    this.rates[from][to] = value;
  }
}

// Использование ровно такое же как и в примерах выше
Money.rates.usd.eur; // 0.7
Money.setRate('usd', 'eur', 0.8);
Money.rates.usd.eur; // 0.8

// Изнутри объектов обращаться можно через this.constructor

```

## Исключения


код, в котором произошла ошибка, выбрасывает исключение, а

код, в котором ошибка обрабатывается – его ловит.

```js

// Функция, которая может выбросить исключение
const readFile = (filepath) => {
  if (!isFileReadable(filepath)) {
    // throw – способ выбросить исключение
    throw new Error(`'${filepath}' is not readable`);
  }
  // ...
};

// Где-то в другом месте программы

const run = (filepath) => {
  try {
    // Функция, которая вызывает readFile. Возможно не напрямую, а через другие функции.
    // Для механизма исключений это не важно.
    readFile(filepath);
  } catch (e) {
    // Этот блок выполняется только в одном случае, если в блоке try было выброшено исключение
    // Любая обработка ошибки, например, вывод в консоль
    console.log(e);
  }
  // Если тут будет код, он продолжит выполняться
};

```

```js 
// Функция, которая может выбросить исключение
const readFile = (filepath) => {
  if (!isFileReadable(filepath)) {
    // throw – способ выбросить исключение
    throw new Error(`'${filepath}' is not readable`);
  }
  // ...
};

// Где-то в другом месте программы

const run = (filepath) => {
  try {
    // Функция, которая вызывает readFile. Возможно не напрямую, а через другие функции.
    // Для механизма исключений это не важно.

    readFile(filepath);
  } catch (e) {
    // Этот блок выполняется только в одном случае, если в блоке try было выброшено исключение
    // Любая обработка ошибки, например, вывод в консоль

    console.log(e);
  }
  // Если тут будет код, он продолжит выполняться

};

```

throw прерывает дальнейшее выполнение кода. В этом смысле оно подобно return, но в отличие от него, прерывает выполнение не только текущей функции, но и всего кода, вплоть до ближайшего в стеке вызовов блока catch.


```js
// Первый блок формируется после try:

try {
  // ...
}
// Любые исключения, которые будут выброшены кодом, расположенным внутри этого блока, будут перехвачены и переданы во второй блок. Если ошибки не было, то этот блок пропускается.

catch (e) {
  // ...
}
// Внутри этого блока будет доступна ошибка в переменной e. Можно задать любое имя переменной:

try {
  // ...
} catch (myError) {
  console.log(myError);
}


// Внутри блока catch можно выполнять любой код, даже выбрасывать новые исключения, которые могут перехватываться блоком try catch уровнем выше:

const myFunc = () => {
  try {
    // ...
  } catch (e) {
    throw new Error('new error');
  }
};

try {
  myFunc();
} catch (e) {
  console.log(e); // => new error
}
```
-------