
```
const sum = (x) => (y) => (z) => x + y + z;

// расставим скобки для того чтобы увидеть как функции вложены друг в друга
// const sum = x => (y => (z => x + y + z));

// sum(1)(3)(5); // 9
```

Функция sum принимает x и возвращает функцию, которая
принимает y и возвращает функцию, которая
принимает z и возвращает сумму x + y + z

```
const generate = (f) => (arg) => f(f(arg));
// const generate = f => (arg => f(f(arg)));
```

Функция generate принимает функцию в качестве аргумента и возвращает новую функцию. Внутри новой функции переданная изначально функция вызывается два раза:

```
const f1 = generate(Math.sqrt);
f1(16); // 2
// generate(Math.sqrt)(16);

const f2 = generate(x => x ** 2);
f2(4); // 256
// generate(x => x ** 2)(4);


const generateDouble = (f) => (arg) => f(f(arg));
const f1 = generateDouble(Math.sqrt);
```

Когда generateDouble закончила работу и вернула новую функцию, экземпляр функции generateDouble исчез, уничтожился вместе с используемыми внутри аргументами.

Но та функция, которую вернула generateDouble, все еще использует аргумент. В обычных условиях он бы навсегда исчез, но тут он «запомнился» или «замкнулся» внутри возвращенной функции. Технически внутренняя функция, как и любая другая в JS, связана со своим лексическим окружением, которое не пропадает, даже если функция покидает это окружение.


Функция, которая была возвращена из generateDouble, называется замыканием. Замыкание — это функция, «запомнившая» часть окружения, где она была задана. Функция замыкает в себе идентификаторы (все, что мы определяем) из лексической области видимости.









