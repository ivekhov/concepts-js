# JS Functions

Based on https://ru.hexlet.io/courses/js-functions/

## Функции

Необязательность передаваемых параметров описывается скобками [ ], точно так же описываются и опциональные параметры, у которых есть значения по умолчанию. Возможность передачи любого числа параметров зашита в этой части [, ...].
```
Math.max([value1[, value2[, ...]]])
```

## Детерминированные функции

Функция называется детерминированной тогда, когда для одних и тех же входных параметров она возвращает один и тот же результат.

Функция, возвращающая случайное число, не является детерминированной, так как у одного и того же входа (даже если он пустой, то есть параметры не принимаются) мы получим всегда разный результат

## Побочные эффекты

С точки зрения программы вывод на экран — это так называемый побочный эффект.

Побочным эффектом называют действия, которые изменяют внешнее окружение (среду выполнения). К таким действиям относятся:

- любые сетевые взаимодействия,
- взаимодействие с файловой системой (чтение и запись файлов),
- вывод информации на экран или печать на принтере,
- и так далее.

Побочные эффекты — один из основных источников проблем и ошибок в программных системах. Код с побочными эффектами сложен в тестировании, ненадежен.

При этом без побочных эффектов программирование не имеет смысла. Без них было бы невозможно получить результат работы программы (записать в базу, вывести на экран, отправить по сети и так далее).

Если вызвать функцию с побочным эффектом дважды с одним и тем же набором значений входных аргументов, может случиться так, что в качестве результата будут возвращены разные значения. Такие функции называются И недетерминированными функциями, И функциями с побочными эффектами.

**Недетерминированность функции** — возможность возвращения функцией разных значений несмотря на то, что ей передаются на вход одинаковые значения входных аргументов. В этом случае невозможно построить однозначную таблицу значений функции; для таких функций таблицы значений выглядят как список (может быть, бесконечный) возможных значений, которые функция принимает на заданном наборе входных параметров.

Функция является детерминированной, если для одного и того же набора входных значений она **возвращает** одинаковый результат.

Другим видом побочных эффектов является модификация переданных в функцию параметров (переменных), когда в процессе вычисления выходного значения функции изменяется и значение входного параметра.

## Побочные эффекты и детерминированность - разные плоскости

Обычно функции, обладающие побочными эффектами, не являются детерминированными, поэтому функции без побочных эффектов, детерминированные функции и чистые функции иногда путают. 

В действительности это разные свойства функций. 

Например, функция rand, которая возвращает случайное число, или гипотетическая функция GetGlobalVarX, которая возвращает значение глобальной переменной X (и больше ничего не делает), не являются детерминированными, хотя они и не обладают побочными эффектами. 

А вот гипотетическая функция print, выводящая текст на экран и всегда возвращающая 0, наоборот — является детерминированной, но обладает побочным эффектом (вывод текста на экран). Ни одна из них не является чистой.

## Чистая функция

Это функция, которая:

1. является детерминированной;
2. не обладает побочными эффектами.

Наличия только одного из свойств недостаточно для того, чтобы функция была чистой.

## Command-query Separation (CQS)

Принцип программирования, изобретённый Бертраном Мейером, создателем языка Eiffel. Согласно этому принципу, каждая функция является либо командой, которая выполняет действие (action), либо запросом (query), который извлекает данные, но не тем и другим одновременно. Команда всегда связана с выполнением побочных эффектов, а чистые функции возможны только для запросов.

Команды по определению выполняют недетерминированный код с побочными эффектами. Недетерминированный, потому что повторный вызов команды приводит либо к ошибке, либо к повторному выполнению действия (хотя их и можно сделать детерминированными, но, как правило, такой код скрывает логические ошибки). Следовательно, выделение запроса (возврата данных) из команды в отдельную функцию, помогает изолировать чистый код от кода с эффектами.

К запросам относятся любые вычисления.
Отсутствие изменения в запросах — очень важный принцип, который нужно соблюдать всегда.

Принцип (правило) наименьшего удивления в эргономике гласит, что если назначение элемента или сочетания неясно, то его поведение должно быть наиболее ожидаемым со стороны пользователя.

## Оператор Rest и упаковка аргументов в определениях функций

```js
const func = (...params) => // ...

// или так
const func = (a, b, ...params) =>  // ...
```
Запись ...params в определении func() из примера выше означает буквально следующее: `"все переданные при вызове функции аргументы поместить в массив params"`.

Если вовсе не передать аргументов, то массив params будет пустым. Но всегда будет отдаваться массив, null не будет.

...params всегда идет в конце списка.

## Оператор spread ...  в вызовах функций


```js
const numbers = [1, 7, 4];

// может использоваться в любом месте списка аргументов
sum(8, 10, ...numbers); // 30
sum(8, ...numbers, 10); // 30
sum(...numbers, 8, 10); // 30
```

## Деструктуризация массива

Деструктуризация массива в теле функции:

```js
// в теле функции
const func = (elements) => {
  const [first, second] = elements;
  console.log(first);
  console.log(second);
};

//  или в определении
const func = ([first, second]) => {
  console.log(first);
  console.log(second);
};
```

Если в передаваемом массиве меньше двух элементов, параметры, которым "не хватило" соответствующих значений, будут содержать undefined. Для таких случаев можно подстраховаться и задать значение по умолчанию:

```js
//
const func = ([first = 666, second = 777]) => {
  console.log(first);
  console.log(second);
};

// [first = 666, second = 777] = [];
func([])
// => 666
// => 777
```


## Деструктуризация объекта

```js

const func = ({ name, surname }) => {
  console.log(name);
  console.log(surname);
};

```

 при деструктуризации необязательно указывать все свойства объекта

 ```js
 const func = ({ surname }) => {
  // берём только значения surname
  console.log(surname);
};

const obj = { name: 'John', surname: 'Doe' };

// let { surname } = { name: 'John', surname: 'Doe' };
func(obj); // => Doe
```

## Объекты первого класса


Это элементы, которые могут быть 
- переданы в функции, 
- возвращены из функций и 
- присвоены переменным (или константам). 

К таким элементам относятся любые данные, например 
- числа, 
- строки, 
- массивы или 
- логические значения.

**В JavaScript функции - это объекты первого рода.**

константу. Только не забывайте об объектной природе функции. В другую константу передается не сама функция, а ссылка на нее

Имя константы – это лишь её имя, а сама функция не имеет имени. Поэтому такие функции в программировании принято называть "анонимными". В других языках анонимные функции нередко называют **лямбда-функциями**. В JavaScript их иногда зовут так же.

## Создание функции внутри другой функции

Раз анонимная функция — выражение, мы можем определять её в любом месте программы, допускающем использование выражений, например, в теле другой функции!

```js
const sum = (a, b) => {
  // определили "внутреннюю" анонимную функцию и
  // сохранили в константе innerSum
  const innerSum = (x, y) => x + y;

  // вызвали внутреннюю функцию и
  // вернули результат вызова наружу из sum
  return innerSum(a, b);
};

sum(1, 4); // 5
```

## Функции высшего порядка 

Функции высшего порядка — это функции, которые либо принимают, либо возвращают другие функции, либо делают всё сразу

Такие функции, как правило, реализуют некий обобщённый алгоритм (например, сортировку), а ключевую часть логики делегируют программисту через функцию. Главный плюс от применения таких функций — сокращение дублирования.


У функции, которая передается внутрь метода sort() есть свое название. Подобные функции называют **колбеками (callback, обратный вызов)**. Колбеком становится любая функция, которая вызывается не напрямую программистом, а ее вызывает какая-то функция, в которую мы передаем наш колбек.

Типичное использование выглядит как прямая передача функции в функцию:
```js
users.sort((a, b) => {
  if (a.age === b.age) {
    return 0;
  }
  return a.age > b.age ? 1 : -1;
});

// То же самое, но используя функцию Math.sign
users.sort((a, b) => Math.sign(a.age - b.age));
```

канонический код на JS выглядит так:
В этом коде присутствует 2 функции высшего порядка (filter() и map()), 2 функции — аргументы и два прохода (это делают функции высшего порядка) по списку пользователей. Код весьма выразителен и лаконичен.

```js
// Просто демонстрация
// Разбирать его не надо
users
  .filter((user) => user.age >= 16)
  .map((user) => `${user.name} is ${user.age} years old`)
  .join('\n');
// => Igor is 19 years old
//    Matvey is 16 years old
```

## Map - отображение. 

В коде мы взяли исходный массив и отобразили его в другой массив, попутно выполнив необходимые преобразования над каждым элементом. Важно, что размер получившегося массива равен размеру исходного массива.

```js
const names = users.map(
  (user) => user.name
);
console.log(names); // => ['Igor', 'Danil', 'Vovan', 'Matvey']

const ages = users.map((user) => user.age);
console.log(ages); // => [19, 1, 4, 16]

//
const numbers = [5, 2, 3];

const newNumbers = numbers.map((number) => number ** 2);
console.log(newNumbers); // => [25, 4, 9]
```

Метод map() принимает первым параметром функцию. 

Дальше, внутри себя, map() перебирает элементы переданной коллекции и для каждого элемента вызывает переданную функцию. 

На вход этой функции передаётся элемент исходного массива, а её результат записывается в новый массив, который и возвращается наружу.

## Filter - фильтрация

Общая схема кода при фильтрации практически один в один как и в отображении, кроме пары ключевых моментов:

- Фильтрация возвращает коллекцию либо того же размера (если ничего не было отфильтровано), либо меньшего. Она может вернуть даже пустую коллекцию, если ни один из элементов не подошёл.
- Фильтрация всегда возвращает исходные элементы. Она никогда не делает отображение. Если на вход фильтрации поступил список пользователей, то список пользователей будет и на выходе.

```js
const filteredUsers = users.filter((user) => user.age > 10);
```

## Reduce - агрегация данных
метод reduce() (говорят "свертка"), который используется для агрегации данных. Под агрегацией понимается операция, вычисляющая значение, зависящее от всего набора данных. К таким операциям, например, относятся нахождение среднего значения, суммы элементов, большего или меньшего

```js
const users = [
  { name: 'Igor', amount: 19 },
  { name: 'Danil', amount: 1 },
  { name: 'Vovan', amount: 4 },
  { name: 'Matvey', amount: 16 },
];

const sum = users.reduce((acc, user) => {
  const newAcc = acc + user.amount;
  return newAcc;
}, 0);
```

```js
const myReduce = (collection, callback, init) => {
  let acc = init; // инициализация аккумулятора
  for (const item of collection) {
    acc = callback(acc, item); // Заменяем старый аккумулятор новым
  }
  return acc;
};

const users = [
  { name: 'Petr', age: 4 },
  { name: 'Igor', age: 19 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];

const oldest = myReduce(
  users,
  (acc, user) => (user.age > acc.age ? user : acc),
  users[0],
);
console.log(oldest); // => { name: 'Igor', age: 19 }
```

Основное отличие агрегации от отображения и фильтрации в том, что результатом агрегации может быть любой тип данных — как примитивный, так и составной, например, массив. 

Кроме того, агрегация нередко подразумевает инициализацию начальным значением, которое принято называть аккумулятором. 

## Сигналы

При использовании функций высшего порядка принято разделять задачу на подзадачи и выполнять их последовательно друг за другом, выстраивая в цепочку операций. Такое решение выглядит как протаскивание данных сквозь цепочку функций-преобразователей.

Сама возможность такого разбиения основывается на простой идее, которую иногда называют "стандартные интерфейсы". Заключается она в том, что на входе и выходе из функций ожидается один и тот же тип данных, в нашем случае, массив. Это позволяет соединять функции и строить цепочки, выполняющие большое количество разных задач, без необходимости реализовывать новые функции. Рассмотренные ранее операции — отображение, фильтрация и агрегация — комбинируясь друг с другом, позволяют решать подавляющее число задач по обработке коллекций. 

## Рекурсия


Подобный итеративный процесс в целом может быть описан так:

1) Определить начальное состояние. В нашем случае мы делаем первый вызов iter() с n и 1. Это начальное состояние
2) Проверить терминальный сценарий. Мы проверяем, не равен ли counter числу 1 и останавливаем рекурсию, когда он принимает значение 1
3) Определить новое состояние. Это то, как процесс двигается вперед. В нашем случае мы делаем еще один вызов iter() с уменьшенным counter и умноженным accumulator. Два этих новых числа определяют новое состояние
4) Повторить шаг 2

И эта штука повторяется, пока не доберётся до терминального сценария.

Давайте повторим вкратце.

- Рекурсия — это когда что-то содержит себя в своём описании
- Рекурсивный процесс — это процесс вычисления с отложенными вычислениями
- Итеративный процесс — это процесс вычисления, когда состояние может быть описано фиксированным количеством значений

Процесс вычисления, который создаёт эта функция, называется рекурсивным процессом. Основная его идея — откладывание вычисления до самого конца.

Вся информация о вычислениях, обо всём, что запоминает программа в любой конкретный момент (вычислениях, константах, функциях), называется состоянием. Множество проблем в программировании рождается из необходимости справиться с состоянием.

Суть итеративного процесса — вычисление с фиксированным количеством состояний.

```js
const factorial = (n) => {
  if (n === 0) {
    return 1;
  }

  const iter = (counter, acc) => {
    if (counter === 1) {
      return acc;
    }
    return iter(counter - 1, counter * acc);
  };

  return iter(n, 1);
};
```
Идея:

- Считаем от n до 1
- Берем число из предыдущего шага
- Умножаем это число на текущее число
- Передаем его в новый шаг
- Когда counter достигает 1, число передаётся из предыдущего шага в ответ

  