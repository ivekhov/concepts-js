# JS Functions

Based on https://ru.hexlet.io/courses/js-functions/

## Функции

Необязательность передаваемых параметров описывается скобками [ ], точно так же описываются и опциональные параметры, у которых есть значения по умолчанию. Возможность передачи любого числа параметров зашита в этой части [, ...].
```
Math.max([value1[, value2[, ...]]])
```

## Детерминированные функции

Функция называется детерминированной тогда, когда для одних и тех же входных параметров она возвращает один и тот же результат.

Функция, возвращающая случайное число, не является детерминированной, так как у одного и того же входа (даже если он пустой, то есть параметры не принимаются) мы получим всегда разный результат

## Побочные эффекты

С точки зрения программы вывод на экран — это так называемый побочный эффект.

Побочным эффектом называют действия, которые изменяют внешнее окружение (среду выполнения). К таким действиям относятся:

- любые сетевые взаимодействия,
- взаимодействие с файловой системой (чтение и запись файлов),
- вывод информации на экран или печать на принтере,
- и так далее.

Побочные эффекты — один из основных источников проблем и ошибок в программных системах. Код с побочными эффектами сложен в тестировании, ненадежен.

При этом без побочных эффектов программирование не имеет смысла. Без них было бы невозможно получить результат работы программы (записать в базу, вывести на экран, отправить по сети и так далее).

Если вызвать функцию с побочным эффектом дважды с одним и тем же набором значений входных аргументов, может случиться так, что в качестве результата будут возвращены разные значения. Такие функции называются И недетерминированными функциями, И функциями с побочными эффектами.

**Недетерминированность функции** — возможность возвращения функцией разных значений несмотря на то, что ей передаются на вход одинаковые значения входных аргументов. В этом случае невозможно построить однозначную таблицу значений функции; для таких функций таблицы значений выглядят как список (может быть, бесконечный) возможных значений, которые функция принимает на заданном наборе входных параметров.

Функция является детерминированной, если для одного и того же набора входных значений она **возвращает** одинаковый результат.

Другим видом побочных эффектов является модификация переданных в функцию параметров (переменных), когда в процессе вычисления выходного значения функции изменяется и значение входного параметра.

## Побочные эффекты и детерминированность - разные плоскости

Обычно функции, обладающие побочными эффектами, не являются детерминированными, поэтому функции без побочных эффектов, детерминированные функции и чистые функции иногда путают. 

В действительности это разные свойства функций. 

Например, функция rand, которая возвращает случайное число, или гипотетическая функция GetGlobalVarX, которая возвращает значение глобальной переменной X (и больше ничего не делает), не являются детерминированными, хотя они и не обладают побочными эффектами. 

А вот гипотетическая функция print, выводящая текст на экран и всегда возвращающая 0, наоборот — является детерминированной, но обладает побочным эффектом (вывод текста на экран). Ни одна из них не является чистой.

## Чистая функция

Это функция, которая:

1. является детерминированной;
2. не обладает побочными эффектами.

Наличия только одного из свойств недостаточно для того, чтобы функция была чистой.

## Command-query Separation (CQS)

Принцип программирования, изобретённый Бертраном Мейером, создателем языка Eiffel. Согласно этому принципу, каждая функция является либо командой, которая выполняет действие (action), либо запросом (query), который извлекает данные, но не тем и другим одновременно. Команда всегда связана с выполнением побочных эффектов, а чистые функции возможны только для запросов.

Команды по определению выполняют недетерминированный код с побочными эффектами. Недетерминированный, потому что повторный вызов команды приводит либо к ошибке, либо к повторному выполнению действия (хотя их и можно сделать детерминированными, но, как правило, такой код скрывает логические ошибки). Следовательно, выделение запроса (возврата данных) из команды в отдельную функцию, помогает изолировать чистый код от кода с эффектами.

К запросам относятся любые вычисления.
Отсутствие изменения в запросах — очень важный принцип, который нужно соблюдать всегда.

Принцип (правило) наименьшего удивления в эргономике гласит, что если назначение элемента или сочетания неясно, то его поведение должно быть наиболее ожидаемым со стороны пользователя.

## Оператор Rest и упаковка аргументов в определениях функций

```js
const func = (...params) => // ...

// или так
const func = (a, b, ...params) =>  // ...
```
Запись ...params в определении func() из примера выше означает буквально следующее: `"все переданные при вызове функции аргументы поместить в массив params"`.

Если вовсе не передать аргументов, то массив params будет пустым. Но всегда будет отдаваться массив, null не будет.

...params всегда идет в конце списка.

## Оператор spread ...  в вызовах функций


```js
const numbers = [1, 7, 4];

// может использоваться в любом месте списка аргументов
sum(8, 10, ...numbers); // 30
sum(8, ...numbers, 10); // 30
sum(...numbers, 8, 10); // 30
```

## Деструктуризация массива

Деструктуризация массива в теле функции:

```js
// в теле функции
const func = (elements) => {
  const [first, second] = elements;
  console.log(first);
  console.log(second);
};

//  или в определении
const func = ([first, second]) => {
  console.log(first);
  console.log(second);
};
```

Если в передаваемом массиве меньше двух элементов, параметры, которым "не хватило" соответствующих значений, будут содержать undefined. Для таких случаев можно подстраховаться и задать значение по умолчанию:

```js
//
const func = ([first = 666, second = 777]) => {
  console.log(first);
  console.log(second);
};

// [first = 666, second = 777] = [];
func([])
// => 666
// => 777
```


## Деструктуризация объекта

```js

const func = ({ name, surname }) => {
  console.log(name);
  console.log(surname);
};

```

 при деструктуризации необязательно указывать все свойства объекта

 ```js
 const func = ({ surname }) => {
  // берём только значения surname
  console.log(surname);
};

const obj = { name: 'John', surname: 'Doe' };

// let { surname } = { name: 'John', surname: 'Doe' };
func(obj); // => Doe
```

## Объекты первого класса


Это элементы, которые могут быть 
- переданы в функции, 
- возвращены из функций и 
- присвоены переменным (или константам). 

К таким элементам относятся любые данные, например 
- числа, 
- строки, 
- массивы или 
- логические значения.

**В JavaScript функции - это объекты первого рода.**

константу. Только не забывайте об объектной природе функции. В другую константу передается не сама функция, а ссылка на нее

Имя константы – это лишь её имя, а сама функция не имеет имени. Поэтому такие функции в программировании принято называть "анонимными". В других языках анонимные функции нередко называют **лямбда-функциями**. В JavaScript их иногда зовут так же.

## Создание функции внутри другой функции

Раз анонимная функция — выражение, мы можем определять её в любом месте программы, допускающем использование выражений, например, в теле другой функции!

```js
const sum = (a, b) => {
  // определили "внутреннюю" анонимную функцию и
  // сохранили в константе innerSum
  const innerSum = (x, y) => x + y;

  // вызвали внутреннюю функцию и
  // вернули результат вызова наружу из sum
  return innerSum(a, b);
};

sum(1, 4); // 5
```

## Функции высшего порядка 

Функции высшего порядка — это функции, которые либо принимают, либо возвращают другие функции, либо делают всё сразу

Такие функции, как правило, реализуют некий обобщённый алгоритм (например, сортировку), а ключевую часть логики делегируют программисту через функцию. Главный плюс от применения таких функций — сокращение дублирования.


У функции, которая передается внутрь метода sort() есть свое название. Подобные функции называют **колбеками (callback, обратный вызов)**. Колбеком становится любая функция, которая вызывается не напрямую программистом, а ее вызывает какая-то функция, в которую мы передаем наш колбек.

Типичное использование выглядит как прямая передача функции в функцию:
```js
users.sort((a, b) => {
  if (a.age === b.age) {
    return 0;
  }
  return a.age > b.age ? 1 : -1;
});

// То же самое, но используя функцию Math.sign
users.sort((a, b) => Math.sign(a.age - b.age));
```

канонический код на JS выглядит так:
В этом коде присутствует 2 функции высшего порядка (filter() и map()), 2 функции — аргументы и два прохода (это делают функции высшего порядка) по списку пользователей. Код весьма выразителен и лаконичен.

```js
// Просто демонстрация
// Разбирать его не надо
users
  .filter((user) => user.age >= 16)
  .map((user) => `${user.name} is ${user.age} years old`)
  .join('\n');
// => Igor is 19 years old
//    Matvey is 16 years old
```

https://ru.hexlet.io/courses/js-functions/lessons/high-order-functions/quiz_unit 